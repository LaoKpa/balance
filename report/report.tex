\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{natbib}
\usepackage{graphicx}
\graphicspath{ {images/} }
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Indicator}{\mathds{1}}
\newcommand{\EX}{\mathbb{E}}
\newcommand{\Prob}{\mathbb{P}}

\author{Andrew Benton}
\title{Constant bounded approximation algorithms for stochastic inventory control}

\begin{document}

\maketitle

\begin{abstract}
A procedure to compute the balancing policy parameters exactly for independent and multivarate normal demand distributions with quadratic convergence. 
\end{abstract}

\section{Introduction}

\cite{levi:2007}, \cite{levi:2008} develop and advance the idea of \textit{Marginal Cost Accounting} and \textit{Cost Balancing}. Marginal Cost Accounting is a method where the total discounted cost of the current decision is computed and minimized. Although similar in effect as a \textit{Dynamic Programming} approach, it differs in that the future costs are separated into their components (holding, backorder, etc), and can be computed for one period without requiring the entire horizon to be solved. Cost Balancing allows for an efficient method of solving the resulting equations, and provides bounds of performance. \cite{hurley:2007} applies these models and shows that these bounds are strong.

\section{Constant Bounded Approximation Algorithms}

\subsection{Key Ideas}

\subsubsection{Marginal Cost Accounting}

A cost accounting scheme assigns costs to particular decisions. A marginal cost accounting scheme is one which after a particular decision is made, that cost can be considered to be unalterable by later decisions. Like a myopic policy, marginal cost accounting schemes give us the ability to select optimal decisions in a particular period without any knowledge of later decisions. Unlike a myopic policy, the costs of the decision in future periods are still considered in the current decision. \\
\\
As an example, we consider holding costs. Holding costs have the property that once an order is placed, the holding costs for the particular items purchased will be incurred until they are consumed by demand. Let $h_j$ be the per unit holding cost in period $j$, $D_{[t,j]}$ be the cumulative demand from period $t$ to $j$, and $X_t$ be the inventory in period $t$. The holding costs incurred by an order of size $Q_t$ in period $t$ are:
$$
	\sum_{j=t}^T h_j (Q_t - (D_{[t,j]} - X_t)^+)^+
$$
Note that this equation does not account for any future decisions, allowing the holding costs to be computed for any demand outcome. This allows the expected holding costs to be computed, provided a distribution over future demands.

\subsubsection{Cost Balancing}

Cost balancing is the component of the algorithm which provides us with bounded cost guarantees. \cite{levi:2007} provide a detailed proof which the later papers are built upon - only a summary will be offered here. They let $Z_t = \EX[H_t^B \; | \; F_t] = \EX[\Pi_t^B \; | \; F_t]$. They then establish the following equivalency with the total cost of the balancing policy:
$$
	\EX[\mathcal{C}(B)] = 2 \sum_t \EX[Z_t]
$$ 
They then partition the horizon into two sets, $\mathcal{J}_H$ and $\mathcal{J}_{\Pi}$, where inventory held is above and below optimal respectively. Using this partition, they establish that:
$$
	H^{opt} + \Pi^{opt} \geq \sum_{t \in \mathcal{J}_H} H_t^B + \sum_{t \in \mathcal{J}_{\Pi}} \Pi_t^B
$$
With these relationships established, it can be shown that $\EX[\mathcal{C}(opt)] \leq \sum_t \EX[Z_t]$ and therefore:
$$
	\EX[\mathcal{C}(B)] \leq 2 \EX[\mathcal{C}(opt)]
$$
Note that this provides no guarantees about average performance, just worst case performance. \cite{hurley:2007} show that average performance is typically superior to twice of optimal, and also provide a set of heuristics for upper and lower bounds for ordering quantity which improve average performance while not violating the constant worst case guarantee. 

\subsection{Applied Models}

\cite{levi:2007} present algorithms for the stochastic inventory control problem and the lot sizing problem. \cite{levi:2008} present algorithms for the capacitated stochastic inventory control problem. \cite{levi:2016} present algorithms for the multi-echelon inventory control problem. For all of these, they present an algorithm as well as worst case performance guarantees. 

\subsection{Stochastic Inventory Problem}

This problem has per unit holding costs $h_s$ and per unit lost sales costs $p_s$. Given the demand sequence $\{z_t\}_t$, a starting inventory $X_t$, the period $s$ holding costs $H^B_s(q_s)$ are computed from the current period to the end of the horizon. 
$$
	H_s^B(q_s) = \sum_{j=s}^T h_j \big[q_s - \big(\sum_{i=s}^j z_i - X_s\big)^+\big]^+
$$
The penalty costs $\Pi_s^B(q_s)$ are simplified by the observation that if too few items are bought during the current period, more can be purchased next period. Due to this, penalty costs only need to be computed for a single period.
$$
	\Pi_s^B(q_s) =  p_s [z_s - (X_s^B + q_s)]^+ 
$$
Using these equations, the Balancing Algorithm seeks the order size $q_s$ where these two costs are equal. That is:
$$
	l_s^B(q_s) = \pi_s^B(q_s)
$$
where $l_s^B(q_s) = \EX[H_s^B(q_s) \; | f_s]$ and $\pi_s^B(q_s) = \EX[\Pi_s^B(q_s) \; | f_s]$. \cite{levi:2007} show that when this $q_s$ is applied, the incurred costs are guaranteed to be twice of the optimal costs.

\subsection{Lot Sizing Problem}

This problem has per unit holding costs $h_s$, per unit lost sales costs $p_s$, and a per order fixed cost $K$. The approach taken by Levi et al. (2007) seeks to separately balance the holding costs and ordering costs as well as the penalty costs and ordering costs. Here, the Balancing Algorithm provides two parameters: the inventory level at which to order, and the level to order up to (analagous to (s, S) in the exact formulation of this problem). An order is made if the backordering costs exceed $K$:
$$
	r_s^B = \min_{q} \{q \; : \; \pi_s^B(q_s) \leq K\} 
$$
The order size is then:
$$
	q_s^B = \max_{q_s} \{q \; : \; l_s^B(q_s) \leq K\} 
$$
\cite{levi:2007} show that when this policy is applied, the incurred costs are guaranteed to be three times of the optimal costs. Unfortunately, these bounds assume that the current period's demand is known deterministically. While this is true in some cases, it does limit the applicability.

\subsection{Capacitated Stochastic Inventory Problem}

This problem has per unit holding costs $h_s$, per unit lost sales costs $p_s$, and a maximum order size $u_s$. This problem is effectively a generalization of the uncapacitated stochastic inventory problem, and the balancing algorithm treats it as such. The holding costs are computed the same, but the penalties must now be computed over the whole horizon:
$$
	\tilde{\Pi} = \sum_{j=s}^T 
$$

\section{Methods for Computing Balancing Policies}

\cite{levi:2007}, \cite{levi:2008}, and \cite{levi:2016} discuss the logic and structure of these algorithms, but offer little advice on how to compute them. \cite{yu:2010} give some detail, but restrict themselves to poisson demand and rely on an graphical method to initialize the algorithm. \cite{hurley:2007} rely on simulation. The following section contains a detailed description of exactly and efficiently computing the balancing policies for independent or multivariate normal demand distributions. 

\subsection{Analysis of Cost Functions}

\subsubsection{Marginal Holding Cost $l_s^B(q_s)$}

Computing $l_s^B(q_s)$ in the general case requires the computation of a $T - s$ dimensional integral. Traditional cubature algorithms have exponential complexity in dimensions, making such an integral unreasonable to compute. However, some conditions allow it to be reduced to $T-s$ integrals of fewer dimensions. Letting $\Phi$ be the (generally multivariate) distribution of forecast $f_s$: 
\begin{alignat*}{1}
	l_s^B(q_s) &= \EX [H_s^B(q_s) \; | \; f_s] \\
        &= \EX \bigg\{\sum_{j=s}^T h_j\bigg[q_s - \bigg(\sum_{i=s}^j z_i - X_s\bigg)^+\bigg]^+  \; | \; f_s \bigg\} \\
		&= \int_{z_s=0}^{\infty} \int_{z_{(s+1)}=0}^{\infty}\dots \int_{z_T=0}^{\infty}\sum_{j=s}^T h_j\bigg[q_s - \bigg(\sum_{i=s}^j z_i - X_s\bigg)^+\bigg]^+ d\Phi(z_s, z_{s+1}, \dots z_T)
\end{alignat*}
Assuming that the demand of any period would depend only on past demand (rather than future demand), this can be rewritten as a series of $1, 2, \dots, T - s$ dimensional integrals: 
\begin{equation*}
	  l_s^B(q_s) = \sum_{j=s}^T \int_{z_s=0}^{\infty} \int_{z_{(s+1)}=0}^{\infty}\dots \int_{z_j=0}^{\infty} h_j\bigg[q_s - \bigg(\sum_{i=s}^j z_i - X_s\bigg)^+\bigg]^+ d\Phi(z_s, z_{s+1}, \dots z_j)
\end{equation*}
Letting $\psi_{[s,j]}$ be the (possibly uncomputable) distribution function of cumulative demand, $l_s^B(q_s)$ and $\frac{d}{d q_s} l_s^B(q_s)$ can be expressed as $T - s$ integrals in one dimension:
\begin{equation}
	l_s^B(q_s) = \sum_{j=s}^T  h_j \int_{z_j=X_s}^{X_s + q_s}\bigg(q_s + X_s - z_j \bigg) \psi_{[s,j]} (z_j) dz_j
\end{equation}
\begin{equation}
	\frac{d}{d q_s} l_s^B(q_s) =  \sum_{j=s}^T h_j \int_{z_j=X_s}^{X_s + q_s}  \psi_{[s,j]}(z_j) dz_j
\end{equation}
For nonincreasing $h_j$, the series in $l_s^B(q_s)$ is nonincreasing. This allows the series to be truncated with a bounded error. This is particularly useful for dependent demand distributions, as it allows us to compute the expectation over fewer random variables (often only 1 or 2 if $q_s$ is below or near its optimal value). So long as the bounded error is less than the tolerance of the quadrature algorithm, this approximation will result in trivial error, while allowing faster function evaluations.\\
\\
For independent demand, $\psi_{[s,j]} = \phi_s \star \phi_{s+1} \star \dots \star \phi_j$.
For distributions with closed-form convolutions (Normal, Exponential, etc), this can be evaluated efficiently. For dependent demand, specialized methods are necessary. If the demand distribution follows a multivariate normal (or can be approximated by one), $\psi_{[s,j]} = N(\sum_{i=s}^j \mu_i, \sqrt{\sum_{i=s}^{j} \sum_{k=s}^j \sigma_{i,k}^2})$\footnote{This is not true in general for dependent normal random variables. However, it does hold for multivariate normal random variables.}. For other distributions, \cite{evans:2004} provide an algorithm for discrete random variables, and \cite{arbenz:2011} provide an algorithm for continuous random variables. Both of these algorithms have superior convergence to Monte Carlo methods for the relevant number of dimensions.\\
\\ 
As an alternative to this entire section, Monte Carlo methods are still quite effective in directly computing $l_s^B(q_s)$, and provide a simple mechanism to integrate forecasting softwares which provide simulated demand paths. The focus here, however, will be on exact solutions. 

\subsubsection{Marginal/Forced Backordering Cost $\tilde{\pi}_s^B(q_s)$}

The derivations and discussion seen above apply here as well. The equivalent results follow:
\begin{equation}
	\tilde{\pi}_s^B(q_s) =  \sum_{j=s}^T \int_{z_j= X_s + q_s + \sum_{i=s}^j u_i }^{\infty} p_j\bigg( z_j - X_s - q_s - \sum_{i=s}^j u_i \bigg)  \psi_{[s,j]}(z_j) dz_j
\end{equation}
\begin{equation}
	\frac{d}{d q_s} \tilde{\pi}_s^B(q_s) = - \sum_{j=s}^T p_j \int_{z_j=X_s + q_s + \sum_{i=s}^j u_i }^{\infty}  \psi_{[s,j]}(z_j) dz_j 
\end{equation}
For nonincreasing $p_j$, the series in $\tilde{\pi}_s^B(q_s)$ is nonincreasing. 

\subsection{Computing Balancing Quantities}

The balancing policies seek the value $q_s^B$ at which some set of costs are equal to another. For instance, the dual balancing policies seek $q_s^B$ such that:
\begin{equation}
	l_s^B(q_s^B) = \pi_s^B(q_s^B)
\end{equation}
The following section will discuss solving equation (5). Adaptations to solve other policies are simple to apply. 

\subsubsection{Exact Solution}

If the conditions to compute $\psi_{[s, j]}$ are met, we can exactly compute the cost functions. If $l_s^B(q_s)$, $\frac{d}{d q_s} l_s^B(q_s)$, $\tilde{\pi}_s^B(q_s)$, and $\frac{d}{d q_s} \tilde{\pi}_s^B(q_s)$ are decreasing with $j$, they can be efficiently computed, with sublinear time complexity in the horizon length.\footnote{No formal proof can be provided, but logically: Assuming the integration is constant per period, computing the entire horizon will be linear with horizon length. If truncated, then there will be some horizon length which, if increased, no further integrations will be required. The only difficulty here is whether each integration is constant. Under the conditions given, this is a trivial formality. Numerical demonstrations will be provided next section.} \\
\\
\cite{levi:2007} suggests using bisection methods (with linear convergence) to solve this. However, under our current assumptions, superior methods can be used. Because $l_s^B(q_s)$ is convex and increasing and $\tilde{\pi}_s^B(q_s)$ is convex and decreasing, (5) has one root, one basin of attraction, no stationary points, and is continuously differentiable. Given these conditions, Newton-Raphson (with quadratic convergence) is a better choice.\footnote{The distinction of quadratic vs. linear convergence is quite critical for these policies: bisection often requires an order of magnitude more function evaluations than the Newton-Raphson. Furthermore, all but the first Newton-Raphson iteration are "very close" to the optimal value, which, as described in Section 3.1, results in faster function evaluation. The overall effect on runtime is several orders of magnitude.}\\
\\
Newton-Raphson begins with an initial estimate $x_0$, and then iterates the following equation:
$$
	x_{n+1} = x_n + \frac{f(x_n)}{f^{\prime}(x_n)}
$$
This is a very standard method - implementations and various modifications are widely available. For the dual balancing policy, $f$ and $f^{\prime}$ would be defined as follows:
$$
	f(x) = l_s^B(x) - \pi_s^B(x) 
$$
$$
	f_s^{\prime}(x) =  \frac{d}{dx} l_s^B(x) - \frac{d}{dx} \pi_s^B(x) 
$$
The only remaining concern when applying Newton-Raphson is the initial estimate $x_0$. Generally, poor initial estimates can cause subquadratic convergence. These concerns can be ignored with the initial estimate of $x_0 = \mu_s$.

\bibliography{citations}
\bibliographystyle{plainnat}

\end{document}
